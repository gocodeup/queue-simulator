<?php

/**
 * Queue class
 *
 * Main driver for queue simulator
 */
class Queue
{
    /**
     * Current entries in the queue, sorted oldest to newest
     *
     * @var int[] $queue Timestamps of when item entered the queue
     */
    protected $queue;

    /** @var float $avgWait Average wait time while on queue */
    protected $avgWait;

    /** @var int $total Total items that have been processed through the queue */
    protected $total;

    /** @var string $filename File where queue data is saved */
    protected $filename;

    /** @var int $skew Clock skew, compensates for gaps between queue runs */
    protected $skew;

    /** @var int $time Current time, updated by tick() */
    protected $time;

    /**
     * Modifier for random number generator.
     *
     * Defines the range of values that will be generated by the random number generator. Range will
     * go from 1 to 2 * MODIFIER + 1. So if MODIFIER is 3, the maximum number of items added or
     * removed from the queue will be 7.
     *
     * @see Queue::tick() For the constant in use
     */
    const MODIFIER = 3;

    /**
     * Queue constructor
     *
     * @param string $filename File to read and write queue data to.
     */
    public function __construct($filename)
    {
        $this->queue   = array();
        $this->avgWait = 0;
        $this->total   = 0;
        $this->skew    = 0;
        $this->time    = time();

        $this->filename = $filename;
    }

    /**
     * Load queue data from Queue::$filename
     *
     * If the file is empty, does not exist, or cannot be read nothing will be done.
     *
     * @throws UnexpectedValueException if the first line of data does not match the expected format
     * @return void
     */
    public function load()
    {
        if (is_readable($this->filename) && filesize($this->filename) > 0) {
            $data = file($this->filename, FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES);

            $head = explode(' ', array_shift($data));

            if (count($head) != 2) {
                throw new UnexpectedValueException('Queue data file heading did not match expected format!');
            }

            $this->total   = $head[0];
            $this->avgWait = $head[1];
            $this->queue   = $data;
        }
    }

    /**
     * Save queue data to Queue::$filename
     *
     * @return void
     */
    public function save()
    {
        $handle = fopen($this->filename, 'w');

        fwrite($handle, "$this->total $this->avgWait\n");

        foreach($this->queue as $line) {
            fwrite($handle, "$line\n");
        }

        fclose($handle);
    }

    /**
     * Calculate skew from loaded queue data.
     *
     * When starting a new simulation from cached data, this method will compensate for
     * the delay between the previous run and the current one. This will avoid any spikes
     * in the maximum wait time & subsequent average wait.
     *
     * @param int $delay Delay between iterations in seconds
     * @return void
     */
    public function calculateSkew($delay)
    {
        if ($delay <= 0) {
            $delay = 1;
        }

        if (empty($this->queue)) {
            $this->skew = 0;
        } else {
            $this->skew = $this->time - end($this->queue) - $delay;
        }
    }

    /**
     * Remove the oldest item from the queue and update the average wait time.
     *
     * If the queue is currently empty, nothing is done.
     *
     * @return void
     */
    protected function remove()
    {
        if (empty($this->queue)) {
            return;
        }

        $item = array_shift($this->queue);

        $this->total++;

        $this->avgWait -=        $this->avgWait / $this->total;
        $this->avgWait += ($this->time - $item) / $this->total;
    }

    /**
     * Add a new item to the queue.
     *
     * @return void
     */
    protected function add()
    {
        $this->queue[] = $this->time;
    }

    /**
     * Driver for queue processing.
     *
     * Remove some random non-zero number of items from the queue.
     * Add some random non-zero number of items to the queue.
     * Random numbers are based on sinusoidal functions of the time to emulate a natural
     * progression in demand and response.
     * Time parameter can be used to run simulation immediately and "emulate" some delay.
     *
     * @param int $time Optional timestamp of current tick
     * @see Queue::MODIFIER For details on random number range modifier
     * @return int Net change in queue length
     */
    public function tick($time = 0)
    {
        $this->time = $time - $this->skew;

        if ($this->time <= 0) {
            $this->time = time() - $this->skew;
        }

        // Add max errs on the "down" side, remove max on the "up" to better our odds of shrinking the queue
        $addMax    = round(static::MODIFIER * (cos(deg2rad($this->time)) + 1) + 1, 0, PHP_ROUND_HALF_DOWN);
        $removeMax = round(static::MODIFIER * (sin(deg2rad($this->time)) + 1) + 1, 0, PHP_ROUND_HALF_UP);

        // Both mins round half up so our minimum to remove will always be at least 1
        $addMin    = round(   $addMax / 2, 0, PHP_ROUND_HALF_UP);
        $removeMin = round($removeMax / 2, 0, PHP_ROUND_HALF_UP);

        $addCount    = mt_rand(   $addMin,    $addMax);
        $removeCount = mt_rand($removeMin, $removeMax);

        for ($i=0; $i < $removeCount; $i++) {
            $this->remove();
        }

        for ($i=0; $i < $addCount; $i++) {
            $this->add();
        }

        return $addCount - $removeCount;
    }

    /** @return float Average wait time on queue */
    public function getAverage()
    {
        return $this->avgWait;
    }

    /** @return float Current oldest item's wait time (with microseconds) */
    public function getMax()
    {
        if (empty($this->queue)) {
            return 0;
        }

        return $this->time - $this->queue[0];
    }

    /** @return int Count of items currently in queue */
    public function getCount()
    {
        return count($this->queue);
    }

    /** @return int Total amount of items that have been processed through the queue */
    public function getTotal()
    {
        return $this->total;
    }
}
